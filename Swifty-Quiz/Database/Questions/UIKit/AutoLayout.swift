//
//  AutoLayout.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 07.11.2021.
//  Copyright © 2021 Evel-Devel. All rights reserved.
//

import Foundation

class AutoLayout {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Auto Layout позволяет вам адаптировать все элементы экрана под разные размеры и режимы отображения. Так ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 618137998,
                     helpText: "Да. Изначально Apple создала iPhone с экраном одного размера, и разработчикам не нужно было создавать гибкие интерфейсы, они должны были соответствовать только одному размеру. Сегодня есть множество устройств разного размера, и большой упор идет на ландшафтный режим отображения. Auto Layout - решение этой проблемы от Apple, позволяющее элементам пользовательского интерфейса увеличиваться, уменьшаться и перемещаться в зависимости от размера экрана."),
            
            Question(question: ["Если вы измените размер окна приложения на macOS, Auto Layout сам перерасчитает интерфейс. Правда ли это?",
                                "Если вы измените ориентацию экрана вашего девайса, Auto Layout сам перерасчитает интерфейс. Правда ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 770323841,
                     helpText: "Auto Layout динамически вычисляет позиции и размеры всех view в иерархии на основе constraints — ограничений, заданных для всех view в иерархии. Самый большой и очевидный плюс для разработчика в использовании Auto Layout в том, что исчезает необходимость в подгонке размеров приложения под определенные устройства — Auto Layout делает это за вас, динамически изменяя интерфейс в зависимости от внешних или внутренних изменений. Примером внешних изменений может быть: Изменение размера окна в macOS, изменение ориентации экрана. Пример внутренних изменений: Изменение контента в окне, изменения в зависимости от языка и т.д."),
            
            Question(question: ["Если контент внутри view изменился, перерасчитает ли Auto Layout ваш интерфейс?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 848679801,
                     helpText: "Да, интерфейс будет перерасчитан. Когда контент вашего приложения изменяется, для нового содержимого может потребоваться другой размер view. Обычно это происходит в приложениях, отображающих текст или изображения. Например, новостному приложению необходимо настроить макет в зависимости от размера отдельных новостных статей. Точно так же фотопоток должен обрабатывать широкий диапазон размеров изображений и соотношений сторон."),
            
            Question(question: ["Autoresizing mask могут поддерживать внутренние изменения (например: изменение контента внутри view). Это правда?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 453857944,
                     helpText: "Вы можете использовать маски с автоизменением размеров (autoresizing mask), они определяют, как изменяется фрейм вашего view при изменении фрейма родительского view. Это упрощает создание макетов, которые адаптируются к внешним изменениям. Однако для сложных пользовательских интерфейсов вам обычно необходимо дополнять маски вашими собственными программными изменениями. Кроме того, маски адаптируются только к внешним изменениям, и не поддерживают внутренние."),
            
            Question(question: ["Какой из этих подходов может реагировать как на внутренние, так и на внешние изменения?"],
                     image: "",
                     optionA: "Auto Layout",
                     optionB: "Autoresizing mask",
                     optionC: "Никакое",
                     optionD: "",
                     questionId: 200521003,
                     helpText: "Auto Layout определяет ваш пользовательский интерфейс с помощью ряда ограничений (constraints). Ограничения обычно представляют собой отношения между двумя view. Затем Auto Layout вычисляет размер и расположение каждого view на основе этих ограничений. Это создает интерфейсы, которые динамически реагируют как на внутренние, так и на внешние изменения."),
            
            Question(question: ["Обязательно ли нам самим, вручную расставлять элементы интерфейса внутри stack view?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 402933862,
                     helpText: "stack views предоставляют простой способ использовать возможности Auto Layout без введения сложных ограничений (constraints). Один stack view представляет из себя либо строку, либо столбец элементов пользовательского интерфейса (то есть бывает и вертикальным, и горизонтальным)."),
            
            Question(question: ["Какие разновидности stack view бывают?"],
                     image: "",
                     optionA: "Горизонтальные и вертикальные",
                     optionB: "Горизонтальные",
                     optionC: "Вертикальные",
                     optionD: "",
                     questionId: 941057637,
                     helpText: "Stack views предоставляют простой способ использовать возможности Auto Layout без введения сложных ограничений (constraints). Один stack view представляет из себя либо строку, либо столбец элементов пользовательского интерфейса (то есть бывает и вертикальным, и горизонтальным)."),
            
            Question(question: ["Сколько основных свойств имеет UIStackView?"],
                     image: "",
                     optionA: "4",
                     optionB: "3",
                     optionC: "2",
                     optionD: "1",
                     questionId: 894853573,
                     helpText: "Правильный ответ - 4. Внутри stack view - все элементы располагаются на основе его свойств. Axis: (только UIStackView) определяет ориентацию представления стека (ось), вертикальную или горизонтальную. Distribution: определяет расположение элементов по оси. Alignment: определяет расположение элементов перпендикулярно оси. Spacing: определяет расстояние между элементами стека."),
            
            Question(question: ["Какое свойство стек-вью отвечает за ориентацию, вертикальную или горизонтальную?"],
                     image: "",
                     optionA: "Axis",
                     optionB: "Distribution",
                     optionC: "Alignment",
                     optionD: "Spacing",
                     questionId: 356536231,
                     helpText: "Внутри stack view - все элементы располагаются на основе его свойств. Axis: (только UIStackView) определяет ориентацию представления стека (ось), вертикальную или горизонтальную. Distribution: определяет расположение элементов по оси. Alignment: определяет расположение элементов перпендикулярно оси. Spacing: определяет расстояние между элементами стека."),
            
            Question(question: ["Какое свойство стек-вью отвечает за расположение элементов по оси?"],
                     image: "",
                     optionA: "Distribution",
                     optionB: "Spacing",
                     optionC: "Axis",
                     optionD: "",
                     questionId: 697503329,
                     helpText: "Внутри stack view - все элементы располагаются на основе его свойств. Axis: (только UIStackView) определяет ориентацию представления стека (ось), вертикальную или горизонтальную. Distribution: определяет расположение элементов по оси. Alignment: определяет расположение элементов перпендикулярно оси. Spacing: определяет расстояние между элементами стека."),
            
            Question(question: ["Какое свойство стек-вью отвечает за расположение элементов перпендикулярно выбранной оси?"],
                     image: "",
                     optionA: "Alignment",
                     optionB: "Spacing",
                     optionC: "Distribution",
                     optionD: "",
                     questionId: 833397952,
                     helpText: "Внутри stack view - все элементы располагаются на основе его свойств. Axis: (только UIStackView) определяет ориентацию представления стека (ось), вертикальную или горизонтальную. Distribution: определяет расположение элементов по оси. Alignment: определяет расположение элементов перпендикулярно оси. Spacing: определяет расстояние между элементами стека."),
            
            Question(question: ["Какое свойство стек-вью определяет расстояние между элементами стека?"],
                     image: "",
                     optionA: "Spacing",
                     optionB: "Axis",
                     optionC: "Distribution",
                     optionD: "",
                     questionId: 222554240,
                     helpText: "Внутри stack view - все элементы располагаются на основе его свойств. Axis: (только UIStackView) определяет ориентацию представления стека (ось), вертикальную или горизонтальную. Distribution: определяет расположение элементов по оси. Alignment: определяет расположение элементов перпендикулярно оси. Spacing: определяет расстояние между элементами вашего стека."),
            
            Question(question: ["Зависит ли расположение элементов внутри stack view от content-hugging priorities?",
                               "Зависит ли расположение элементов внутри stack view от compression-resistance priorities?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 505206643,
                     helpText: "stack view также основывает свой макет на приоритетах упорядоченного содержимого (content-hugging priorities) и приоритетах сопротивления сжатию (compression-resistance priorities). Вы можете изменить их в size-инспекторе (правая панель Interface builder). Вы можете дополнительно изменить макет, добавив constraints непосредственно в stack view."),
            
            Question(question: ["Можем ли мы использовать constraints внутри stack view?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 460023123,
                     helpText: "Для получения максимально удовлетворящих вас результатов, вы можете использовать constraints внутри самого stackView, либо вкладывать несколько stackView в stackView и затем использовать constraints, например: для выравнивания по центру экрана."),
            
            Question(question: ["Swift не поддерживает вложенные stack view, вы не можете поместить один в другой. Правда ли это?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Да",
                     optionC: "",
                     optionD: "",
                     questionId: 961339359,
                     helpText: "Вы можете вкладывать несколько stack view один в другой, и затем даже использовать constraints, чтобы получить более сложные макеты, отвечающие вашим требованиям."),
            
            Question(question: ["Apple советует в своей верстке использовать максимально возможное количество stack views. Правда ли это?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 445353624,
                     helpText: "Согласно Apple Layout Guide: Используйте stack views, чтобы управлять как можно большей частью вашего макета. Прибегайте к созданию констрейнтов (ограничения / constraints) только тогда, когда вы не можете достичь своих целей с помощью одних стек-вью. Хотя креативное использование вложенных стеков поможет вам создавать сложные пользовательские интерфейсы, вы не можете полностью избежать использования ограничений (constraints). Как минимум, вам всегда нужны ограничения для определения позиции (и, возможно, размера) самого внешнего стека."),
            
            Question(question: ["Можем ли мы сверстать сложный пользовательский интерфейс, используя только stack view (совсем не используя constraints)?"],
                     image: "",
                     optionA: "Нет, не можем",
                     optionB: "Да, можем",
                     optionC: "",
                     optionD: "",
                     questionId: 389087092,
                     helpText: "Хотя креативное использование вложенных стеков поможет вам создавать сложные пользовательские интерфейсы, вы не можете полностью избежать использования ограничений (constraints). Как минимум, вам всегда нужны ограничения для определения позиции (и, возможно, размера) самого внешнего стека (родительского, расположенного на главном view)."),
        ]
    }
}
