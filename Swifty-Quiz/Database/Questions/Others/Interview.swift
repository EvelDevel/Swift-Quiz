//
//  Interview.swift
//  Swifty-Quiz
//
//  Created by Евгений Никитин on 20.01.2023.
//  Copyright © 2023 Evel-Devel. All rights reserved.
//

import Foundation

class Interview {
    static func getQuestions() -> [Question] {
        return [
            Question(question: [
                "С помощью чего происходит управление памятью в Swift?"
            ],
                     image: "",
                     optionA: "ARC",
                     optionB: "MRC",
                     optionC: "Вручную",
                     optionD: "",
                     questionId: 342790056,
                     links: [
                        "https://swiftbook.ru/content/languageguide/automatic-reference-counting/#:~:text=Swift%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D1%83%D0%B5%D1%82%20automatic%20reference%20counting,%D0%B4%D1%83%D0%BC%D0%B0%D1%82%D1%8C%20%D0%BE%20%D1%81%D0%B0%D0%BC%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%BC%20%D1%83%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E."
                     ],
                     helpText: """
                     ARC. Swift использует automatic reference counting (автоматический подсчет ссылок) для отслеживания и управления памятью вашего приложения. В большинстве случаев это означает, что управление памятью "просто работает" в Swift и вам не нужно думать о самостоятельном управлении.
                     
                     ARC автоматически освобождает память, которая использовалась экземплярами класса, когда эти экземпляры больше нам не нужны (на экземпляр нет сильных ссылок).
                     """
                    ),
            
            Question(question: [
                "Какими типами ссылок мы можем ссылаться на объект в Swift?"
            ],
                     image: "",
                     optionA: "Strong, weak, unowned",
                     optionB: "strong, unowned",
                     optionC: "direct, weak, strong",
                     optionD: "",
                     questionId: 678255779,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Сильной или слабой. В основе механизма работы с памятью лежит система подсчёта ссылок на объекты (ARC).
                     На объект можно ссылаться сильной (strong) или слабой (weak) ссылкой.
                     
                     Сильные ссылки держат объект и препятствуют его очистке из памяти. Как только количество сильных ссылок станет равным нулю - объект будет очищен из памяти. Таким образом разработчику не требуется управлять всем вручную, но важно корректно расставлять типы ссылок.
                     """
                    ),
            
            Question(question: [
                "При каком количестве сильных ссылок в Swift, объект будет очищен из памяти?"
            ],
                     image: "",
                     optionA: "0",
                     optionB: "1",
                     optionC: "Не имеет значения",
                     optionD: "",
                     questionId: 537225677,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     0. Сильные ссылки держат объект и препятствуют его очистке из памяти. Как только количество сильных ссылок станет равным нулю - объект будет очищен из памяти. Таким образом разработчику не требуется управлять всем вручную, но важно корректно расставлять типы ссылок.
                     
                     Для корректного подсчёта этих ссылок существуют ARC (Automatic Reference Counter) и MRC (Manual Reference Counter). Как можно понять из названия, один из них считает ссылки автоматически, другой - в ручную.
                     """
                    ),
            
            Question(question: [
                "Ситуация, при которой два объекта ссылаются друг на друга сильными ссылками"
            ],
                     image: "",
                     optionA: "Retain cycle",
                     optionB: "Reference type",
                     optionC: "Deadlock",
                     optionD: "",
                     questionId: 713615594,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Retain cycle. Цикл сильных ссылок - это когда объем выделенного пространства в памяти не может быть освобожден из-за циклов сохранения. Поскольку Swift использует автоматический подсчет ссылок (ARC), цикл сохранения происходит, когда два или более объекта содержат сильные ссылки друг на друга.
                     
                     В результате эти объекты сохраняют друг друга в памяти, потому что их счетчик никогда не уменьшится до 0, что предотвратит вызов функции deinit и освобождение памяти.
                     
                     Например, у нас есть класс, которому нужен делегат - weak var delegate: SomeDelegateProtocol?. Если мы укажем его сильной ссылкой, то образуется Retain Cycle. Наш класс не должен препятствовать объекту-делегату очиститься из памяти, когда его жизненный цикл закончился.
                     """
                    ),
            
            Question(question: [
                "Область памяти, для которой свойственно статическое выделение памяти, которое происходит только во время компиляции"
            ],
                     image: "",
                     optionA: "Стек",
                     optionB: "Куча",
                     optionC: "",
                     optionD: "",
                     questionId: 486217799,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Стек. Область памяти, для которой свойственно статическое выделение памяти, которое происходит только во время компиляции.
                     
                     Переменные, выделенные в стеке, хранятся непосредственно в памяти, и доступ к этой памяти очень быстрый, и ее выделение определяется при компиляции программы. Он организован по принципу «последним пришёл — первым вышел» (LIFO).
                     
                     Существует ограничение в том, что данные, которые предполагается хранить в стеке, обязаны быть конечными и статичными — их размер должен быть известен ещё на этапе компиляции. Каждый поток многопоточного приложения имеет доступ к своему собственному стеку.
                     """
                    ),
            
            Question(question: [
                "Область памяти, для которой свойственно динамическое выделение памяти, которое происходит во время выполнения"
            ],
                     image: "",
                     optionA: "Куча",
                     optionB: "Стек",
                     optionC: "",
                     optionD: "",
                     questionId: 607469139,
                     links: [
                        "https://habr.com/ru/post/592385/"
                     ],
                     helpText: """
                     Куча. Используется для динамического выделения памяти, однако, в отличие от стека, данные в куче первым делом требуется найти с помощью «оглавления». Можно представить, что куча это такая большая многоуровневая библиотека, в которой, следуя определённым инструкциям, можно найти необходимую книгу.
                     
                     Операции на куче производятся несколько медленнее, чем на стеке, так как требуют дополнительного этапа для поиска данных. В куче хранятся данные динамических размеров, например, список, в который можно добавлять произвольное количество элементов. Куча общая для всех потоков приложения.
                     
                     Вследствие динамической природы, куча нетривиальна в управлении и с ней возникает большинство всех проблем и ошибок, связанных с памятью. Способы решения этих проблем предоставляются языками программирования.
                     """
                    ),
        ]
    }
}
