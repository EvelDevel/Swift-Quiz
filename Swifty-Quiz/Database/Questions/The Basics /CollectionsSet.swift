
//  Created by Евгений Никитин on 10.05.2020.
//  Copyright © 2020 Evel-Devel. All rights reserved.

import Foundation

class CollectionsSet {
    static func getQuestions() -> [Question] {
        return [
            Question(question: ["Какое значение будет в переменной length?"],
                     image: "Collections01",
                     optionA: "5",
                     optionB: "6",
                     optionC: "4",
                     optionD: "",
                     questionId: 379461209,
                     helpText: "Правильный ответ: 5. При инициализации массива firstArray в secondArray - мы создаем копию этого массива, и изменяя один из экземпляров - никак не влияем на второй (все стандартные типы в Swift являются типами значения - value types). При добавлении числа 6 в secondArray через .append, в firstArray у нас так и останется 5 элементов."),
            
            Question(question: ["Какие значения мы получим в консоль после запуска этого кода?"],
                     image: "Collections02",
                     optionA: "false, true",
                     optionB: "false, false",
                     optionC: "true, false",
                     optionD: "true, true",
                     questionId: 754078264,
                     helpText: "При сравнении array и array2 мы получим false, потому что массивы сравниваются как есть, и наши массивы содержат разное количество элементов, соответственно - они не могут быть равны. Но когда мы приводим наши массивы к множествам, в которых элементы не могут дублироваться (множество это коллекция уникальных элементов) - мы удаляем повторяющиеся значения, и у нас остаются одинаковые элементы в равных количествах."),
            
            Question(question: ["Какие значения мы получим в консоль после запуска этого кода?"],
                     image: "Collections03",
                     optionA: "false, false",
                     optionB: "false, true",
                     optionC: "true, false",
                     optionD: "true, true",
                     questionId: 127980411,
                     helpText: "Как массивы, так и наборы (после удаления дублирующихся значений), будут содержать разные элементы. Поэтому оба сравнения дадут нам false."),
            
            Question(question: ["Последовательность (Sequence), в которой можно обращаться к отдельному элементу напрямую"],
                     image: "",
                     optionA: "Коллекция",
                     optionB: "Кортеж",
                     optionC: "Опционал",
                     optionD: "",
                     questionId: 857640149,
                     helpText: "Коллекция (Collection) — это последовательность (Sequence), в которой можно обращаться к отдельному элементу напрямую. Другими словами, Collection — это протокол, основанный на протоколе Sequence, который при этом имеет дополнительное требование по обеспечению прямого доступа к элементам. Также коллекция не может быть бесконечной (в отличие от Sequence)."),
            
            Question(question: ["Сколько основных типов коллекций обеспечивает Swift?",
                                "Swift поддерживает именно столько основных типов коллекций",
                                "Какое количество типов коллекций поддерживается в Swift?"],
                     image: "",
                     optionA: "Три",
                     optionB: "Два",
                     optionC: "Четыре",
                     optionD: "Пять",
                     questionId: 571685140,
                     helpText: "Swift обеспечивает три основных типа коллекций - это Массивы, Множества и Словари для хранения коллекций значений."),
            
            Question(question: ["Упорядоченная коллекция значений",
                                "Коллекция с упорядоченными значениями",
                                "Упорядоченные значения, объединенные в коллекцию"],
                     image: "",
                     optionA: "Массив",
                     optionB: "Словарь",
                     optionC: "Множество",
                     optionD: "",
                     questionId: 981639342,
                     helpText: "Массивы - это упорядоченные коллекции значений. Массивы хранят много значений одинакового типа в упорядоченном списке. Одно и то же значение в массиве может появиться несколько раз, в разных позициях."),
            
            Question(question: ["Неупорядоченная коллекция уникальных значений",
                                "Уникальные значения, собранные в неупорядоченную коллекцию",
                                "Коллекция неупорядоченных уникальных значений"],
                     image: "",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     questionId: 355306978,
                     helpText: "Множества - это неупорядоченные коллекции уникальных значений."),
            
            Question(question: ["Неупорядоченная коллекция, хранящая пары ключ-значение",
                                "Коллекция, хранящая неупорядоченные пары ключ-значение",
                                "Неупорядоченные пары ключ-значение хранятся именно в этой коллекции"],
                     image: "",
                     optionA: "Словарь",
                     optionB: "Множество",
                     optionC: "Массив",
                     optionD: "",
                     questionId: 308436207,
                     helpText: "Словари - это неупорядоченные коллекции, хранящие пары ключ-значение. Словарь представляет собой контейнер, который хранит несколько значений одного и того же типа. Каждое значение связано с уникальным ключом, который выступает в качестве идентификатора этого значения внутри словаря. В отличие от элементов в массиве, элементы в словаре не имеют определенного порядка. Используйте словарь, когда вам нужно искать значения на основе их идентификатора, так же как в реальном мире словарь используется для поиска определения конкретного слова."),
            
            Question(question: ["Какой тип коллекции на изображении?"],
                     image: "Collections5",
                     optionA: "Словарь",
                     optionB: "Множество",
                     optionC: "Массив",
                     optionD: "",
                     questionId: 438685776,
                     helpText: "На изображении словарь, коллекция пар ключ-значение"),
            
            Question(question: ["Какой тип коллекции на изображении?",
                                "Укажите какой тип коллекции изображен на изображении?",
                                "На этом изображении именно этот тип коллекции"],
                     image: "Collections8",
                     optionA: "Массив",
                     optionB: "Множество",
                     optionC: "Набор",
                     optionD: "Словарь",
                     questionId: 184948656,
                     helpText: "На изображении массив, упорядоченная коллекция значений, доступных по индексу."),
            
            Question(question: ["Какой тип коллекции на изображении?",
                                "Укажите какой тип коллекции показан на изображении?",
                                "На этом изображении именно этот тип коллекции"],
                     image: "Collections9",
                     optionA: "Множество",
                     optionB: "Массив",
                     optionC: "Словарь",
                     optionD: "",
                     questionId: 100663625,
                     helpText: "На изображении множество, неупорядоченная коллекция уникальных значений."),
            
            Question(question: ["Если коллекция присвоена константе, можем ли мы ее изменять?",
                                "Можем ли мы изменять словарь или массив, если он присвоен константе?",
                                "Возможно ли изменять множество, если при создании мы присвоили его константе?"],
                     image: "",
                     optionA: "Нет",
                     optionB: "Можем добавлять элементы",
                     optionC: "Можем удалять элементы",
                     optionD: "Да",
                     questionId: 789561026,
                     helpText: "Когда вы присвоите массив или словарь константе, то он будет неизменяемым, а его размер и содержимое не может быть изменено. Хорошей практикой является создание неизменяемых коллекций во всех случаях, когда коллекцию не нужно менять. Делая это, мы позволяем компилятору Swift оптимизировать производительность наших коллекций."),
            
            Question(question: ["Как пишется полная форма записи массива в Swift?",
                                "Полная форма записи массива в Swift пишется так",
                                "Как нужно писать полную форму записи массива в Swift?"],
                     image: "",
                     optionA: "Array<ElementType>",
                     optionB: "[ElementType]",
                     optionC: "[ElementType]()",
                     optionD: "Array(ElementType)[]",
                     questionId: 501843423,
                     helpText: "Полная форма записи массива в Swift пишется Array<ElementType>, где ElementType это тип значений, которые могут храниться в массиве."),
            
            Question(question: ["Что мы используем для доступа к элементам коллекции?"],
                     image: "",
                     optionA: "Индекс",
                     optionB: "Значение элемента",
                     optionC: "Волшебное слово",
                     optionD: "",
                     questionId: 372971495,
                     helpText: "Для доступа к элементам коллекции используются индексы. Они могут быть представлены как в виде обычного числового значения (порядковый номер элемента), так и в виде более сложных структур (как, например, в словарях или строках). То есть обращаясь к коллекции и сообщая ей индекс интересующего вас элемента, вы получите значение именно того элемента, индекс которого передали. Но при этом элементы коллекции точно так же могут последовательно перебираться."),
            
            Question(question: ["Как пишется сокращенная форма записи массива в Swift?",
                                "Сокращенная форма записи массива в Swift пишется так",
                                "Как нужно писать сокращенную форму записи массива в Swift?"],
                     image: "",
                     optionA: "[ElementType]",
                     optionB: "Array<ElementType>",
                     optionC: "[ElementType]()",
                     optionD: "Array(ElementType)[]",
                     questionId: 768291993,
                     helpText: "Вы можете также написать массив в сокращенной форме как [ElementType]. Хотя две формы функционально идентичны, краткая форма является предпочтительной."),
            
            Question(question: ["Как можно создать пустой массив с помощью синтаксиса инициализатора?",
                                "Как вы можете создать пустой массив?",
                                "Пустой массив инициализируется именно так"],
                     image: "",
                     optionA: "var array = [String]()",
                     optionB: "var array = (String)[]",
                     optionC: "var array = [String()]",
                     optionD: "var array: [String]?",
                     questionId: 703702168,
                     helpText: "Вы можете создать пустой массив определенного типа с помощью синтаксиса инициализатора: var array = [String]()."),
            
            Question(question: ["Является ли коллекция последовательностью?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 508411585,
                     helpText: "Коллекция (Collection) — это последовательность (Sequence), в которой можно обращаться к отдельному элементу напрямую. Другими словами, Collection — это протокол, основанный на протоколе Sequence, который при этом имеет до- полнительное требование по обеспечению прямого доступа к элементам. Также коллекция не может быть бесконечной (в отличие от Sequence)."),
            
            Question(question: ["Альтернативный способ создания пустого массива",
                                "Альтернативный вариант, как вы можете создать пустой массив",
                                "Пустой массив может инициализироваться именно так"],
                     image: "",
                     optionA: "var array: [String] = []",
                     optionB: "var array: String = []",
                     optionC: "var array = String()",
                     optionD: "var array: [String]?",
                     questionId: 563632176,
                     helpText: "В качестве альтернативы синтаксису инизиализатора, вы можете создать пустой массив с помощью пустого литерала массива, который записывается в виде [] (пустой пары квадратных скобок)."),
            
            Question(question: ["Какой тип будет у данного массива ints, и что будет внутри?",
                                "Выберите ответ с правильным типом и содержанием коллекции ints",
                                "Выберите тип и содержание данного массива ints"],
                     image: "Collections15",
                     optionA: "[Double] и [0.0, 0.0, 0.0]",
                     optionB: "[Int] и [0, 0, 0]",
                     optionC: "[Double] и [0, 0, 0]",
                     optionD: "[Int] и [0.0, 0.0, 0.0]",
                     questionId: 326073251,
                     helpText: "Если не указывать иного, Swift присвоит массиву чисел с плавающей точкой тип [Double], а данный инициализатор массива указывает, что в этом массиве должны быть числа 0.0, повторяющиеся три раза. То есть правильный ответ будет [Double], [0.0, 0.0, 0.0]."),
            
            Question(question: ["Как мы можем создать новый массив, объединив два существующих массива с совместимыми типами?",
                                "Каким образом мы можем создать новый массив из двух существующих (их типа совместимы)?",
                                "Из двух существующих массивов с одинаковым типом необходимо создать новый, как это сделать?"],
                     image: "",
                     optionA: "Сложить (+)",
                     optionB: "Используя интерполяцию",
                     optionC: "Через свойство .insert",
                     optionD: "Логическим оператором И &&",
                     questionId: 461226350,
                     helpText: "Вы можете создать новый массив, объединив два существующих массива с совместимыми типами с оператором сложения (+). Новый тип массива выводится из типа двух массивов, которые вы объединяете вместе. Так же можно добавить один массив к другому через firstArray.append(contentsOf: secondArray)."),
            
            Question(question: ["Выберите создание массива через синтаксис литерала массива",
                                "Какой из этих способов описывается как «создание массива через литерал массива»?",
                                "Мы можем создать массив с помощью синтаксиса литерала массива именно так"],
                     image: "",
                     optionA: "var nums: [Int] = [0, 1, 2, 3]",
                     optionB: "var nums: Int = [0, 1, 2, 3]",
                     optionC: "var nums: [Int] = 0, 1, 2, 3",
                     optionD: "var nums: [Int](0, 1, 2, 3)",
                     questionId: 874476168,
                     helpText: "Вы можете инициализировать массив с помощью литерала массива, который является быстрым способом писать одно или несколько значений как набор значений массива. Литерал массива пишется в виде списка значений, разделенных запятыми и окруженными парами скобок: [value 1, value 2, value 3]. Пример: создается массив под названием numbers для хранения Int значений: var number: [Int] = [1, 2, 3, 4, 5]."),
            
            Question(question: ["В каком из этих случаев мы можем не указывать тип массива?",
                                "Выберите вариант, в котором мы можем убрать указание типа массива, и это не вызовет ошибку?",
                                "Выберите вариант, при котором мы можем убрать явное указание типа массива?"],
                     image: "",
                     optionA: "var array: [Int] = [1, 2]",
                     optionB: "var array = [String]()",
                     optionC: "var array = [Int](1, 2, 3)",
                     optionD: "var array = []",
                     questionId: 374489271,
                     helpText: "Благодаря выводу типов Swift, вы можете не писать тип для массива, который вы инициализируйте с помощью литерала массива, хранящего значения того же типа, например var array: [Int] = [1, 2]. Вместо этого, инициализация array может быть записана в сокращенной форме: var array = [1, 2]. Поскольку все значения внутри литерала массива одинакового типа (Int), Swift может вывести, что [Int] является правильным типом для переменной array."),
            
            Question(question: ["Быстрый способ получить количество элементов массива?",
                                "Получить количество элементов массива можно через это свойство",
                                "Какое свойство поможет вам получить количество элементов массива?"],
                     image: "",
                     optionA: "array.count",
                     optionB: "array.sort()",
                     optionC: "array.prefix()",
                     optionD: "array.append()",
                     questionId: 421477900,
                     helpText: "Чтобы узнать количество элементов в массиве, проверьте его свойство count."),
            
            Question(question: ["Что выведется в консоль после запуска данного кода?",
                                "Какой результат запуска мы увидим в консоли?",
                                "Выберите вариант, который окажется в консоли после запуска этого кода"],
                     image: "Collections20",
                     optionA: "Array is empty",
                     optionB: "Array is not empty",
                     optionC: "Ничего не выведет",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 742701915,
                     helpText: "Логическое свойство isEmpty можно использовать в качестве быстрого способа узнать, является ли свойство count равным 0. В данном примере у нас пустой массив array, значит мы пройдем проверку по первому условию и выведем «Array is empty»"),
            
            Question(question: ["Куда добавляется элемент, когда мы вносим его в массив через .append?",
                                "Как добавится элемент, когда мы вставляем его в массив через .append?",
                                "Если мы добавим элемент в массив через .append, куда он поместится?"],
                     image: "",
                     optionA: "В конец массива",
                     optionB: "В начало массива",
                     optionC: "Посередине",
                     optionD: "",
                     questionId: 665837498,
                     helpText: "Через вызов метода append вы можете добавлять новые элементы в конец массива."),
            
            Question(question: ["Какой результат мы получим, после запуска этого кода?"],
                     image: "Collections22",
                     optionA: "Столкнемся с ошибкой",
                     optionB: "[0.1, 1.1, 1.2, 2.2, 3.4]",
                     optionC: "Массив не изменится",
                     optionD: "Ничего",
                     questionId: 159946881,
                     helpText: "Добавить массив с одним или несколькими совместимыми (типами) элементами можно с помощью оператора сложения с присвоением (+=), но в данном случае мы столкнемся с ошибкой, поскольку numbers является константой."),
            
            Question(question: ["Что будет содержаться внутри массива numbers после выполнения этого кода?",
                                "Какие значения будут содержаться внутри numbers в результате?",
                                "Выберите верный вариант итогового вида массива numbers"],
                     image: "Collections23",
                     optionA: "[1.0, 2.0, 3.0, 4.0, 5.0]",
                     optionB: "[1.0, 2.0, 3, 4, 5]",
                     optionC: "[1, 2, 3, 4, 5]",
                     optionD: "[1.0, 2.0]",
                     questionId: 739767869,
                     helpText: "Правильный ответ [1.0, 2.0, 3.0, 4.0, 5.0]. Оператор присваивания со сложением добавит в данный массив значения 3, 4 и 5, но, так как массив numbers имеет тип [Double], значения примут вид 3.0, 4.0, 5.0."),
            
            Question(question: ["Как с помощью синтаксиса сабскриптов извлечь значение из массива?",
                                "В каком из вариантов используется корректное обращение к элементу массива с помощью синтаксиса сабскриптов?",
                                "Как выглядит извлечение из массива с помощью синтаксиса сабскриптов?"],
                     image: "",
                     optionA: "arrayName[1]",
                     optionB: "arrayName(0)",
                     optionC: "arrayName-2",
                     optionD: "arrayName.3",
                     questionId: 488128173,
                     helpText: "Можно извлечь значение из массива с помощью синтаксиса сабскриптов, поместив индекс значения, который вы хотите получить, внутри квадратных скобок сразу после имени массива. Первый элемент в массиве имеет индекс 0, а не 1. Массивы в Swift всегда начинаются с 0."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections25",
                     optionA: "[1.0, 2.0, 1.0, 4.0]",
                     optionB: "[1.0, 2.0, 3.0, 4.0]",
                     optionC: "[1.0, 2.0, 3.0, 1.0]",
                     optionD: "[1.0, 1.0, 3.0, 4.0]",
                     questionId: 112337298,
                     helpText: "Вы можете использовать синтаксис сабскриптов для изменения существующего значения по указанному индексу. Правильный ответ: [1.0, 2.0, 1.0, 4.0], поскольку мы инициализируем новое значение элементу массива, который находится на индексе [2], начиная с 0 это будет третий элемент (3.0)."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections26",
                     optionA: "[1.0, 4.0, 5.0, 6.0]",
                     optionB: "[1.0, 4, 5, 6]",
                     optionC: "[1.0, 2.0, 3.0, 4.0]",
                     optionD: "[4.0, 5.0, 6.0, 4.0]",
                     questionId: 279950267,
                     helpText: "Вы можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяемых значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Правильный ответ: [1.0, 4.0, 5.0, 6.0], поскольку мы меняем значения с 1 по 3 индекс, а это 2.0, 3.0, 4.0."),
            
            Question(question: ["Какие элементы будут в массиве numbers после выполнения данного кода?",
                                "Выберите итоговый порядок элементов массива numbers после исполнения данного кода",
                                "После выполнения кода, какой порядок элементов будет у массива numbers?"],
                     image: "Collections27",
                     optionA: "[1.0, 2.0, 11.0, 12.0, 13.0, 5.0]",
                     optionB: "[1.0, 2.0, 11.0, 12.0, 5.0]",
                     optionC: "[1.0, 2.0, 11.0, 12.0]",
                     optionD: "[1.0, 2.0, 11.0, 12.0, 13.0]",
                     questionId: 293242951,
                     helpText: "Вы можете использовать синтаксис сабскриптов для изменения диапазона значений за раз, даже если набор изменяемых значений имеет разную длину, по сравнению с диапазоном который требуется заменить. Правильный ответ: [1.0, 2.0, 11.0, 12.0, 13.0, 5.0], поскольку мы меняем значения с 2 по 3 индекс, а это 3.0, 4.0, но вставляем уже три элемента, вместо удаленных двух."),
            
            Question(question: ["Вызов какого метода поможет вставить элемент в массив на определенный индекс?",
                                "Чтобы вставить элемент на определенный индекс массива, какой мы будем использовать метод?",
                                "Какой метод нужно использовать, чтобы вставить элемент на определенный индекс массива?"],
                     image: "",
                     optionA: "insert(_:at:)",
                     optionB: ".append",
                     optionC: "add(_:at:)",
                     optionD: "remove(_ :at:)",
                     questionId: 287081136,
                     helpText: "Для вставки элемента по заданному индексу внутрь массива, вызовите его метод insert(_:at:)."),
            
            Question(question: ["Вызов какого метода поможет удалить элемент из массива с определенного индекса?",
                                "Чтобы удалить элемент с определенного индекса массива, какой мы будем использовать метод?",
                                "Какой метод нужно использовать, чтобы удалить элемент с определенного индекса массива?"],
                     image: "",
                     optionA: "remove(_ :at:)",
                     optionB: ".append",
                     optionC: "add(_:at:)",
                     optionD: "insert(_:at:)",
                     questionId: 38286348,
                     helpText: "Можно удалить элемент из массива с помощью метода remove(at:). Этот метод удаляет элемент с указанным индексом и возвращает удаленный элемент (хотя вы можете проигнорировать возвращаемое значение, если оно вам не нужно)."),
            
            Question(question: ["Что будет, если вы попытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива?",
                                "Если вы попытаетесь изменить значение индекса, который находится за пределами существующих границ массива, что произойдет?"],
                     image: "",
                     optionA: "Ошибка исполнения",
                     optionB: "Вернется nil",
                     optionC: "Ничего не произойдет",
                     optionD: "Вернется последний элемент",
                     questionId: 541953975,
                     helpText: "Если вы пытаетесь получить доступ или изменить значение индекса, который находится за пределами существующих границ массива, у вас будет ошибка исполнения. Вы можете проверить, действителен ли индекс, прежде чем его использовать, сравнив его с свойством count массива. За исключением случаев, когда count равен 0 (то есть массив пуст), самый большой валидный индекс в массиве всегда будет count - 1, так как массивы индексируются с нуля."),
            
            Question(question: ["Какие элементы будут содержаться в массиве после выполнения этого кода?",
                                "Выберите какие значения будут содержаться в массиве после исполнения insert и remove?"],
                     image: "Collections30",
                     optionA: "[2, 3, 9, 4, 5]",
                     optionB: "[1, 2, 3, 9, 4, 5]",
                     optionC: "[1, 2, 3, 4, 5]",
                     optionD: "[1, 2, 3, 9, 4]",
                     questionId: 166266577,
                     helpText: "Сначала numbers.insert(9, at: 3) добавляет девятку на третий индекс, то есть между тройкой и четверкой, после чего numbers.remove(at: 0) удаляет единицу, которая находится на нулевом индексе. Получается [2, 3, 9, 4, 5]."),
            
            Question(question: ["Как мы можем удалить один или несколько последних элементов массива, при этом вернуть оставшийся массив?",
                                "Каким методом вы можете удалить несколько последних значений массива, и вернуть то, что осталось?",
                                "Выберите метод, который позволит вам удалить несколько последних элементов массива и вернуть оставшееся"],
                     image: "",
                     optionA: "array.dropLast()",
                     optionB: "array.removeLast()",
                     optionC: "array.remove(_ :at:)",
                     optionD: "array.deleteLast()",
                     questionId: 225059326,
                     helpText: "Если вы хотите удалить последний или несколько последних элементов из массива, вы можете использовать метод dropLast(), в скобках необходимо указать количество элементов, которые вы хотите удалить. После реализации данного метода вам вернется оставшаяся последовательность."),
            
            Question(question: ["Каким методом мы можем удалить последний элемент массива, и сразу вернуть его?",
                                "Какой метод удаляет последний элемент массива, и возвращает его?",
                                "Этим методом можно удалить последний элемент массива и вернуть его"],
                     image: "",
                     optionA: "array.removeLast()",
                     optionB: "array.remove(_ :at:)",
                     optionC: "array.dropLast()",
                     optionD: "array.deleteLast()",
                     questionId: 448130194,
                     helpText: "Если вы хотите удалить последний элемент из массива, то можно использовать метод removeLast() вместо remove(at:), чтобы избежать необходимости запроса свойства count для массива. Также как и метод remove(at:), removeLast() возвращает удаленный элемент."),
            
            Question(question: ["Какими будут значения переменных first и second?",
                                "Выберите, какими будут значения переменных first и second"],
                     image: "Collections34",
                     optionA: "[1, 2, 3] и 4",
                     optionB: "[1, 2, 3, 4] и 4",
                     optionC: "[1, 2, 3, 4, 5] и 5",
                     optionD: "[1, 2, 3, 4] и 5",
                     questionId: 686187366,
                     helpText: "Первое выражение var first = numbers.dropLast() присвоит переменной first массив с оставшимися элементами, это [1, 2, 3, 4]. Второе выражение var second = first.removeLast() присвоит переменной second последний элемент массива first, то есть цифру 4, но при этом он удалит ее из этой переменной, и там останется только [1, 2, 3]. Правильный ответ: [1, 2, 3], 4." ),
            
            Question(question: ["Каким образом можно выполнить самое просто итерирование массива?",
                                "Этим способом можно выполнить простое итерирование массива, возвращая только элементы без индексов",
                                "Как мы можем выполнить просто итерирование массива, чтобы возвращать только элементы без индексов?"],
                     image: "",
                     optionA: "цикл for-in",
                     optionB: "цикл while",
                     optionC: "enumerated()",
                     optionD: "switch-case",
                     questionId: 654991144,
                     helpText: "Вы можете выполнить итерацию по всему набору значений внутри массива с помощью цикла for-in. Но если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте вместо этого глобальную функцию enumerated() для итерации по массиву. Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента."),
            
            Question(question: ["Каким образом мы можем итерировать массив, чтобы вернуть кортежи значений, содержащие индекс и значение, находящееся на этом индексе?",
                                "Этим способом можно итерировать массив, возвращая кортежи значений, состоящие из индекса и значения, находящегося на этом индексе",
                                "С помощью этой глобальной функции мы можем итерировать массив и вернуть кортежи, состоящие из индексов и значений, находящихся на этих индексах."],
                     image: "",
                     optionA: "for-in и enumerated()",
                     optionB: "for-in и sorted()",
                     optionC: "repeat-while",
                     optionD: "while",
                     questionId: 562087283,
                     helpText: "Если вам нужен целочисленный индекс каждого значения так же как и само значение, используйте глобальную функцию enumerated() для итерации по массиву. Функция enumerated() возвращает кортеж для каждого элемента массива, собрав вместе индекс и значение для этого элемента. При этом вы можете разложить кортеж во временные константы или переменные в рамках итерации: for (index, value) in someArray.enumerated() { print(index, value) }"),
            
            Question(question: ["Какие значения мы получим в консоль после запуска?",
                                "Что эта программа выведет в консоль?",
                                "Какие данные мы получим в консоль после запуска?"],
                     image: "Collections37",
                     optionA: "0 - 0.1 и 1 - 0.2",
                     optionB: "1 - 0.1 и 2 - 0.2",
                     optionC: "Ничего не получим",
                     optionD: "index - value и index - value",
                     questionId: 341343070,
                     helpText: "0 - 0.1 и 1 - 0.2"),
            
            Question(question: ["Какое значение будет у константы first?"],
                     image: "Collections69",
                     optionA: "9",
                     optionB: "10",
                     optionC: "8",
                     optionD: "Столкнемся с ошибкой",
                     questionId: 908641032,
                     helpText: "Числам (индексам) ниже 10 можно приписывать нули. В этой стилистической надстройке нет прямой необходимости, но иногда она может сделать код более читаемым."),
            
            Question(question: ["У стандартных типов коллекций в Swift есть оптимизация, позволяющая сократить затраты на копирование большого количества элементов, из-за нее элементы копируются... ",
                                "Чтобы минимизировать затраты на копирование большого количества элементов у типов коллекций (массив, словарь, строка), в Swift используется данная оптимизация: \"Элементы копируются...\""],
                     image: "",
                     optionA: "Прямо перед модификацией",
                     optionB: "Не копируются",
                     optionC: "В глобальном потоке",
                     optionD: "Специальным алгоритмом",
                     questionId: 470520042,
                     helpText: "Коллекции, определенные стандартной библиотекой, такие как массивы, словари и строки, используют оптимизацию для снижения затрат на копирование. Вместо того, чтобы немедленно сделать копию, эти коллекции совместно используют память, в которой элементы хранятся между исходным экземпляром и любыми копиями. Если одна из копий коллекции модифицирована, элементы копируются непосредственно перед изменением."),
            
            Question(question: ["Что мы получим в консоль?",
                                "Какие значения мы получим в консоль?"],
                     image: "Collections74",
                     optionA: "[1, 2, 3]",
                     optionB: "0, 1, 2",
                     optionC: "[2, 3, 4]",
                     optionD: "3",
                     questionId: 130568136,
                     helpText: "prefix(_ maxLength: Int) возвращает последовательность, состоящую из исходных элементов коллекции, в количестве maxLength, указанном пользователем, начиная с начала исходной последовательности. То есть мы получим [1, 2, 3]."),
            
            Question(question: ["Что мы получим в консоль?"],
                     image: "Collections75",
                     optionA: "[3, 4, 5]",
                     optionB: "[1, 2, 3]",
                     optionC: "[2, 3, 4]",
                     optionD: "3",
                     questionId: 860936709,
                     helpText: "suffix(_ maxLength: Int) возвращает последовательность, состоящую из исходных элементов коллекции, в количестве maxLength, указанном пользователем, начиная с конца исходной последовательности. То есть мы получим [3, 4, 5]. Если maxLength превышает количество элементов исходной последовательности - мы получим все ее элементы."),

            Question(question: ["При фильтрации словаря через .filter исходная коллекция остается неизменной. Так ли это?",
                                "Результатом фильтрации словаря через .filter является новая коллекция того же типа, это правда?"],
                     image: "",
                     optionA: "Да",
                     optionB: "Нет",
                     optionC: "",
                     optionD: "",
                     questionId: 120284511,
                     helpText: "В результате фильтрации словаря через .filter {} нам вернется новая коллекция того же типа, что и исходная. Старая коллекция остается неизменной."),
            
            Question(question: ["Что будет напечатано в консоль?"],
                     image: "Collections04",
                     optionA: "Set<Int>",
                     optionB: "Set",
                     optionC: "Array",
                     optionD: "Array<Int>",
                     questionId: 425560646,
                     helpText: "Правильный ответ: Set<Int>."),
        ]
    }
}
